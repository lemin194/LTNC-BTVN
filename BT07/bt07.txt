Bai 1;
1, Loi con tro chua khoi tao - con tro tro den mot dia chi rac
=> Output: 0x1 (luon luon la 0x1)
2, Loi con tro NULL
=> Output: luon la 0
3, int a = 10, b = 9;
	cout << weird_sum(a, b);
=> Output: 0x6ffdc (đừng giữ con trỏ tới biến có phạm vi
nhỏ hơn chính biến con trỏ đó.)
4, chay code trang 16 luon co mot ket qua giong nhau trong khi
ket qua cua co khac
5, khong hieu phan doi kieu lam?? chay code trang 17 khong co van
de gi
6, void*

Kiểu con trỏ trỏ đến loại dữ liệu không xác
định kiểu.
7, Hang con tro
const int* p1 = &a; // con trỏ tới hằng int

int* const p2 = &b; // hằng con trỏ

const int* const p3 = &c; // hằng con trỏ tới hằng int
7.2, Cac thao tac tren hang con tro
*pA += 1 // sai vi *pA la gia tri tai pA ma da khai bao la hang int

*pB += 1 // khong hieu?? khong co loi gi het
*pC += 1 // sai vi pC chi den mot gia tri la const

7.3,
pB = NULL; // assignment of read-only variable 'pB'
pC = NULL; // assignment of read-only variable 'pC'

8; Nguyen tac lap trinh: KHOA TAT CA NHUNG GI CO THE KHOA
=> GAN CONST vao tat ca nhung gi KHONG NEN BI SUA GIA TRI

9; 
==, !=, >, < so sánh địa chỉ lưu bởi hai con trỏ

++, -- , +, -, +=, -= với một số nguyên làm thay
đổi giá trị con trỏ một khoảng bằng số nguyên
đó nhân với kích thước của kiểu dữ liệu.

10; 
khong chap nhan: &a (a la mot con tro); **a (khong xac dinh);
chap nhan: *a

Bai 2 (BT08)
1; 
tham số kiểu int, cùng kiểu trả về, x và y cùng là biến địa phương đầu tiên của hàm, do đó khả năng lớn là trình biên dịch xếp x và y ở cùng một địa chỉ.

void f(int xval)
{
   int x;
   x = xval;
   // in địa chỉ của x tại đây
}
void g(int yval)
{
   int y;
   // in địa chỉ của y tại đây
}
int main()
{
   f(7);
   g(11);
   return 0;
} 
2;
int main( )
{ 
   char a[4] = "abc"; 
   for (char *cp = a; (*cp) != '\0'; cp++) {
      cout << (void*) cp << " : " << (*cp) << endl;
   } 
   return 0;
}
=> tai sao lai can void* ??
3;